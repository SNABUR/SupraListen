# Spike Indexer Project Context

## Overview

This project is a Next.js application that serves as an indexer for the Spike AMM (Automated Market Maker) on a Move-based blockchain (Supra). The primary purpose of this indexer is to gather on-chain data, process it, and store it in a structured format for use by front-end applications and other services.

The project is built with TypeScript and uses Prisma as the ORM to interact with a PostgreSQL database (hosted on Supabase). It features a robust, modular task processing system for running scheduled background jobs.

## Key Components

- **Next.js:** The core framework for the application.
- **Prisma:** The ORM used to manage the PostgreSQL database schema and queries.
- **`spike_indexer/prisma/schema.prisma`:** Defines the database schema for the main application, including the `Ammpair`, `staking_pools`, and `protocol_stats` models. This is the primary database, considered the Single Source of Truth for curated data.
- **`amm_indexer` (External Data Source):** A separate project that indexes raw on-chain events (swaps, etc.) for the Spike AMM and stores it in a **SQLite** database. This provides the real-time activity data.
- **`spike_indexer/lib/tasks/executeUpdateAmmData.ts`:** The main **orchestrator** task for the data update cycle. It does not contain business logic itself, but rather coordinates calls to various processor modules.
- **`spike_indexer/lib/tasks/update-cycle/`:** A directory containing the modularized logic for the update cycle:
    - **`data-fetcher.ts`:** Responsible for all read operations from both the PostgreSQL and SQLite databases.
    - **`amm-pair-processor.ts`:** Contains all business logic related to AMM pairs, including TVL and 24h APR calculations.
    - **`staking-pool-processor.ts`:** Contains all business logic for calculating TVL and APR for staking pools.
    - **`protocol-stats-processor.ts`:** Handles the aggregation and updating of global platform statistics.
    - **`utils.ts`:** Contains shared helper functions used by the processors.

## Data Flow & Architecture

The main objective of the update cycle is to enrich the main PostgreSQL database with calculated metrics derived from raw on-chain data.

1.  **Data Fetching:** The `executeUpdateAmmData.ts` orchestrator begins by calling `data-fetcher.ts` to gather all necessary data:
    - **From PostgreSQL (Supabase):** Curated data like token prices, token decimals, and staking pool information.
    - **From SQLite (`amm_indexer`):** Raw data like recent swap events and AMM pair reserves.
2.  **In-Memory Processing:** The fetched data is passed to the processor modules (`amm-pair-processor.ts`, `staking-pool-processor.ts`). These modules perform all calculations in memory, using the token address as a "bridge" to combine the raw data from SQLite with the pricing data from PostgreSQL.
3.  **Transactional Write:** All database update operations generated by the processors are collected and executed in a single, atomic transaction against the PostgreSQL database. This ensures data integrity.

This modular architecture allows for easy extension. For example, to add new metrics like 7-day volume, only the relevant processor (`amm-pair-processor.ts`) would need to be modified.
